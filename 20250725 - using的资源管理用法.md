除了using可以当作引入命名空间。
>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using

```
using System;
```

外，在method内使用method可以暂时的引入一个资源，结束后自动释放非托管资源。

```
using (DisposableObject obj = new DisposableObject())
{
    // 使用 obj
} // 离开作用域时，自动调用 obj.Dispose()
```

为什么需要 using？
在C#中，垃圾回收器（GC）只能管理托管内存，但无法自动释放非托管资源（如文件、数据库连接、网络套接字等）。
如果不手动释放这些资源，可能会导致：

>内存泄漏（文件句柄未关闭）
>资源耗尽（数据库连接未释放，导致连接池满）
>数据损坏（文件写入未正确关闭）

using 语句提供了一种结构化、安全的方式来确保资源被释放。

典型使用场景
(1) 文件读写（StreamReader, StreamWriter）
```
using (StreamReader reader = new StreamReader("file.txt"))
{
    string content = reader.ReadToEnd();
    Console.WriteLine(content);
} // 自动关闭文件，释放资源
```

using 语句本质上就是 try-finally 的语法糖，但更简洁。
```
StreamReader reader = null;
try
{
    reader = new StreamReader("file.txt");
    string content = reader.ReadToEnd();
    Console.WriteLine(content);
}
finally
{
    if (reader != null)
        reader.Dispose(); // 确保资源释放
}
```

Unity 中的 IDisposable 对象
```
using (UnityWebRequest webRequest = UnityWebRequest.Get("https://example.com"))
{
    yield return webRequest.SendWebRequest();
    Debug.Log(webRequest.downloadHandler.text);
} // 自动释放网络请求资源
```

数据库连接（SqlConnection）
