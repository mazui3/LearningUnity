Transform point = Instantiate(pointPrefab);
point.SetParent(transform);

公司写的代码里一些gameObject以及Prefab用的是路径而不是[SerializeField]链接.
有些我觉得挺有道理的.
一些用[SerializeField]的代码上有些难找.
只要策划不需要定义的话.


Create a custom shader to get the functionality that we want.
Create one via Assets / Create / Shader / Standard Surface Shader and name it Point Surface.
Our shader file contains code to define a surface shader, which uses different syntax than C#.
It contains a surface shader template, but we'll delete everything and start from scratch to create a minimal shader.

噢？shader是一种不同的语言？

It begins with the Shader keyword followed by a string defining a menu item for the shader.

Shaders can have multiple sub-shaders, each defined by the SubShader keyword followed by a code block.
Below the sub-shader we also want to add a fallback to the standard diffuse shader, by writing FallBack "Diffuse".
>A fallback value refers to a default or alternative value assigned to a variable, property, or function when the originally intended value is unavailable or cannot be determined.

Shader "Graph/Point Surface" {

	SubShader {}

	FallBack "Diffuse"
}

The sub-shader of a surface shader needs a code section written in a hybrid of CG and HLSL, two shader languages.
This code must be enclosed by the CGPROGRAM and ENDCG keywords.
>HLSL - High-Level Shading Language

The first needed statement is a compiler directive, known as a pragma.
>A compiler directive is a statement that causes the compiler to take a specific action during compilation.

It's written as #pragma followed by a directive.

To make this work in a surface shader we have to define the input structure for our configuration function.
It has to be written as struct Input followed by a code block and then a semicolon.

Below that we define our ConfigureSurface method, although in the case of shaders it's always referred to as a function, not as a method.
It is a void function with two parameters.
First is an input parameter that has the Input type that we just defined.
The second parameter is the surface configuration data, with the type SurfaceOutputStandard.
The second parameter must have the inout keyword written in front of its type, which indicates that it's both passed to the function and used for the result of the function.

Shader "Graph/Point Surface" {

	SubShader {
    CGPROGRAM
    #pragma surface ConfigureSurface Standard fullforwardshadows
    #pragma target 3.0

    struct Input {
      float3 worldPos;
    };
    ENDCG
  }

	FallBack "Diffuse"
}

>When writing shader code we do not have to add the f suffix to float values.

The default style is to prefix shader configuration options with an underscore and capitalize the next letter, so we'll use _Smoothness.

void ConfigureSurface (Input input, inout SurfaceOutputStandard surface) {
  surface.Smoothness = _Smoothness;
}

To make this configuration option appear in the editor we have to add a Properties block at the top of the shader, above the sub-shader.
Write _Smoothness in there, followed by ("Smoothness", Range(0,1)) = 0.5.
This gives it the Smoothness label, exposes it as a slider with the 0–1 range, and sets its default to 0.5.

Shader "Graph/Point Surface" {

	Properties {
		_Smoothness ("Smoothness", Range(0,1)) = 0.5
	}

	SubShader {
		…
	}
}

To adjust the color of our points we have to modify surface.Albedo.

刚刚的那些代码是制作了default render用的代码.

接下来做URP中的render,以上写的不能用.

>Universal and High-Definition render pipelines, URP and HDRP.

使用URP先在package manager里面下载universal RP.

We first have to create an asset for it, via Assets / Create / Rendering / Universal Render Pipeline / Pipeline Asset (Forward Renderer).
I named it URP. This will also automatically create another asset for a renderer, in my case named URP_Renderer.

Next, go to the Graphics section of the project settings and assign the URP asset to the Scriptable Renderer Pipeline Settings field.

>To switch back to the default render pipeline later simply set Scriptable Renderer Pipeline Settings to None.
This can only be done in the editor, the render pipeline cannot be changed in a built stand-alone app.

Create a new shader graph via Assets / Create / Shader / Universal Render Pipeline / Lit Shader Graph and name it Point URP.

We have to create a separate shader for the URP.
We could write one ourselves, but that's currently very hard and likely to break when upgrading to a newer URP version.
The best approach is to use Unity's shader graph package to visually design a shader.
URP depends on this package so it was automatically installed along with the URP package.

The graph can be opened by double-clicking its asset in the project window or by pressing the Open Shader Editor button in its inspector.
This opens a shader graph window for it, which might be cluttered by multiple nodes and panels. These are the blackboard, graph inspector, and main preview panels, which can be resized and can also be hidden via toolbar buttons.
There are also two linked nodes: a Vertex node and a Fragment node.
These two are used to configure the output of the shader graph.

哇有stand alone editor.

From this point you can use either the default render pipeline or the URP.
After switching from one to the other you'll also have to change the material of the Point prefab otherwise it will be magenta.

We can do this for our surface shader by passing the generated color through the saturate function.
This is a special function that clamps all components to 0–1.
It is a common operation in shaders known as saturation, hence its name.

surface.Albedo.rg = saturate(input.worldPos.xy * 0.5 + 0.5);

The same can be done in the shader graph with the Saturate node.
