今天改了一个bug。\
指定士兵先移动再攻击。\
在移动结束后和攻击开始前那一短暂时间内，操作页面会出现，拼手速可以释放也应该消费回合行动数的技能。

翻了会代码。\
先翻了点击地块。
分为
 - BoardLogic,整个棋局用
 - BoardTile,整个棋盘用
 - BoardTileLogic,每个棋盘里的格子

大部分写在BoardTileLogic里面了。\
棋子怎么做，BoardTileLogic传过去，例如：\
TileSelected，如果这个格子里有棋子，then the棋子.Selected，处理棋子被选中的状况。\
计算单位是否可站在当前地块。\
计算穿越地块需要的移动值。\
改地块地形对属性的加成。\
该地块周围的友方地方等单位。

棋子有state，很有道理。\
```
public enum PiecesState
{
  None = -1,
  Selected = 0,
  Moving = 1,
  Attacking = 2,
  Die = 3,
  //等等
  Max
}
```

不过按钮本身放在了GameUI里面显示处理，毕竟要写addListener的表现层，也有道理。

然后从GameUI过来，再传到棋子里是否可以使用主动技能。\
咦，这个主动技能的判定没有pieceLogic的状态欸。\
只是单纯的看技能前置条件，是否有行动轮，是否已经被使用过。

可能是GameUI的显示与非显示，就是一种约束主动技能的可使用和非可使用，但他们没有以棋子状态联系在一起。

如果写得更好一些，应该给棋子“移动”+“攻击”这个命令的时候已经把moveTurn给处理好了。\
看了一下代码，移动，和攻击，是两个式子（其实很有道理），也许给棋子的行为是写成array？ToDoFollowingAction[] ？\
